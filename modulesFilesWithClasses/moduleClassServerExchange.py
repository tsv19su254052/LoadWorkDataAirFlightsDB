#  Interpreter 3.7 -> 3.10


import pyodbc  # v. 5.0.1 - fixme вызов хранимых процедур EXECUTE ... не работает -> обновил до 5.1.0, работает
import pymssql  # v. 2.3.0 работает тяжелее - fixme не подключается
# todo Вероятно придется много переделать, чтобы не вызывать по 2 раза. Не работает с XML-ными полями см. https://docs.sqlalchemy.org/en/20/dialects/mssql.html#sqlalchemy.dialects.mssql.XML
from sqlalchemy import create_engine


# Делаем предков
class ServerExchange:
    def __init__(self, c, s):
        self.cnxn = c  # подключение
        self.seek = s  # курсор

    """
    Библиотеки Python для ввода-вывода в файл:
     - Pandas (анализ данных, лучше чем NumPy),
     - math (математические функции),
     - SciPy (математика),
     - SymPy,
     - MatPlotLib (графики на плоскости),
     - Pickle (пишут, что ненадежен -> лучше json),
     - dbm,
     - shelve (чтение и запись в файл),
     - sys (система),
     - os (операционная система),
     - time, datetime (дата и время)

    Обмен данными между программами:
     - двоичный файл типа *.dat,
     - текстовый файл типа *.txt,
     - файл с разделителями и переводом строки типа *.csv,
     - файл с тэгами и иерархией типа *.xml (xml.dom, xml.sax) или *.html (XML-RPC, WDDX, WSDL),
        XQuery для информационно-ориентированного XML
        XSLT для документно-ориентированного XML (может переводить XML в формат представления HTML или PDF)
        Схемы:
         - схема XDR с заметками (устаревшая до SQLXML 4.0)
         - схема XSD (полнее, чем XDR) с заметками,  файл типа *.xsd
         - типы данных и операторы XPath & XQuery,
         - типы данных XDR,
         - типы данных XSD
     - файл кодера-декодера исходный текст типа *.json,
     - файл типа *.yaml
     - файл MsgPack, Protocol Buffers, Avro, Thrift
     - с помощью модуля pickle,
     - научный формат HDF5,
     - БД с помощью DB-API (функционал - connect, cursor, execute, fetch) нет своего функционала для прямой работы с таблицами SQL Server-а
     (для выборки вызываем скрипт на SQL или хранимую процедуру с параметрами на входе),
     - файл формата dbm (словарь),
     - python-memcached,
     - сервер структурных данных Redis,

    ----
    Общее для 3-х нижеприведенных - Транзакция не может прочитать данные,
    которые были изменены и еще не зафиксированы другими транзакциями.
    
    Выборка и все остальное - ставим READ COMMITTED (Чтение зафиксированных данных - в настройках по умолчанию) - Другие транзакции могут изменять
     и вставлять данные, читаемые текущей транзакцией.

    Обновление - ставим REPEATABLE READ (Повторяемость чтения) - Другие транзакции могут только вставлять данные, читаемые текущей транзакцией.

    Вставка - ставим SERIALIZABLE (Упорядочиваемость) - Другие транзакции не могут изменять и вставлять данные в диапазон, читаемые текущей транзакцией.
    ----
    
    Одновременно может быть установлен только один параметр уровня изоляции, который продолжает действовать для текущего соединения до тех пор,
    пока не будет явно изменен. Все операции считывания, выполняемые в рамках транзакции, функционируют в соответствии с правилами уровня изоляции,
    если только табличное указание в предложении FROM инструкции не задает другое поведение блокировки ... WITH (ROWLOCK, UPDLOCK) ... или управления версиями строк для таблицы.

    Уровни изоляции транзакции определяют тип блокировки, применяемый к операциям считывания. Совмещаемые блокировки,
    применяемые для READ COMMITTED или REPEATABLE READ, как правило, являются блокировками строк, но при этом,
    если в процессе считывания идет обращение к большому числу строк, блокировка строк может быть расширена до блокировки страниц или таблиц.
    Если строка была изменена транзакцией после считывания, для защиты такой строки транзакция применяет монопольную блокировку,
    которая сохраняется до завершения транзакции.
    Например, если транзакция REPEATABLE READ имеет разделяемую блокировку строки и при этом изменяет ее, совмещаемая блокировка преобразуется в монопольную.

    В любой момент транзакции можно переключиться с одного уровня изоляции на другой, однако есть одно исключение.
    Это смена уровня изоляции на уровень изоляции SNAPSHOT. Такая смена приводит к ошибке и откату транзакции.
    Однако для транзакции, которая была начата с уровнем изоляции SNAPSHOT, можно установить любой другой уровень изоляции.

    Когда для транзакции изменяется уровень изоляции, ресурсы, которые считываются после изменения, защищаются в соответствии с правилами нового уровня.
    Ресурсы, которые считываются до изменения, остаются защищенными в соответствии с правилами предыдущего уровня.
    Например, если для транзакции уровень изоляции изменяется с READ COMMITTED на SERIALIZABLE,
    то совмещаемые блокировки, полученные после изменения, будут удерживаться до завершения транзакции.

    Если инструкция SET TRANSACTION ISOLATION LEVEL использовалась в хранимой процедуре или триггере,
    то при возврате управления из них уровень изоляции будет изменен на тот, который действовал на момент их вызова.
    Например, если уровень изоляции REPEATABLE READ устанавливается в пакете, а пакет затем вызывает хранимую процедуру,
    которая меняет уровень изоляции на SERIALIZABLE, при возвращении хранимой процедурой управления пакету,
    настройки уровня изоляции меняются назад на REPEATABLE READ

    ----
    Уровень изоляции транзакций по умолчанию в SQL Server — READ COMMITTED.
     Если база данных не настроена на поддержку изоляции SNAPSHOT по умолчанию,
     операция записи внутри транзакции в режиме изоляции READ COMMITTED устанавливает блокировки на уровне транзакции для обновленных строк.
     В условиях высокой параллельности МОГУТ ПРОИЗОЙТИ БЛОКИРОВКИ, если несколько процессов генерируют конфликтующие блокировки.
     Если эти процессы используют долгоживущие транзакции, генерирующие большое количество таких блокировок, вероятность возникновения взаимоблокировки возрастает.

     Установка autocommit=True позволит избежать взаимоблокировок, поскольку каждый отдельный оператор SQL будет автоматически зафиксирован.
     тем самым завершая транзакцию (которая автоматически запускалась, когда этот оператор начал выполняться) и снимая все блокировки обновленных строк.
    """

    def connectDB_odbc(self, driver, servername, database):
        self.Result = False
        try:
            # через драйвер СУБД + клиентский API-курсор
            self.cnxn = pyodbc.connect(driver=driver, server=servername, database=database)
            # Разрешаем транзакции и вызываем функцию commit() при необходимости в явном виде, в СУБД по умолчанию FALSE
            self.cnxn.autocommit = False
            # Делаем свой экземпляр и ставим курсор
            # КУРСОР нужен для перехода функционального языка формул на процедурный или для вставки процедурных кусков в функциональный скрипт.
            #
            # Способы реализации курсоров:
            #  - SQL, Transact-SQL,
            #  - серверные API-курсоры (OLE DB, ADO, ODBC),
            #  - клиентские API-курсоры (выборка кэшируется на клиенте)
            #
            # API-курсоры ODBC по SQLSetStmtAttr:
            #  - тип SQL_ATTR_CURSOR_TYPE:
            #    - однопроходный (последовательный доступ),
            #    - статический (копия в tempdb),
            #    - управляемый набор ключей,
            #    - динамический,
            #    - смешанный
            #  - режим работы в стиле ISO:
            #    - прокручиваемый SQL_ATTR_CURSOR_SCROLLABLE,
            #    - обновляемый (чувствительный) SQL_ATTR_CURSOR_SENSITIVITY

            # Клиентский однопроходной, статический API-курсор ODBC.
            # Добавляем атрибут seek...
            self.seek = self.cnxn.cursor()
            self.Result = True
        except Exception:
            self.Result = False
        return self.Result

    def connectDB_mssql(self, servername, database):
        self.Result = False
        try:
            # через драйвер СУБД + клиентский API-курсор
            # Разрешаем транзакции и вызываем функцию commit() при необходимости в явном виде
            #self.cnxn = pymssql.connect(server=servername, database=database, host=host, autocommit=False)
            self.cnxn = pymssql.connect(server=servername, database=database, autocommit=False)
            # Делаем свой экземпляр и ставим курсор
            # КУРСОР нужен для перехода функционального языка формул на процедурный или для вставки процедурных кусков в функциональный скрипт.
            #
            # Способы реализации курсоров:
            #  - SQL, Transact-SQL,
            #  - серверные API-курсоры (OLE DB, ADO, ODBC),
            #  - клиентские API-курсоры (выборка кэшируется на клиенте)
            #
            # API-курсоры ODBC по SQLSetStmtAttr:
            #  - тип SQL_ATTR_CURSOR_TYPE:
            #    - однопроходный (последовательный доступ),
            #    - статический (копия в tempdb),
            #    - управляемый набор ключей,
            #    - динамический,
            #    - смешанный
            #  - режим работы в стиле ISO:
            #    - прокручиваемый SQL_ATTR_CURSOR_SCROLLABLE,
            #    - обновляемый (чувствительный) SQL_ATTR_CURSOR_SENSITIVITY

            # Клиентский однопроходной, статический API-курсор ODBC.
            # Добавляем атрибут seek...
            self.seek = self.cnxn.cursor()
            self.Result = True
        except Exception:
            self.Result = False
        return self.Result

    def connectDSN_odbc(self, dsn):
        self.Result = False
        try:
            # через DSN + клиентский API-курсор (все настроено и протестировано в DSN)
            self.cnxn = pyodbc.connect("DSN=" + dsn)
            # Разрешаем транзакции и вызываем функцию commit() при необходимости в явном виде, в СУБД по умолчанию FALSE
            self.cnxn.autocommit = False
            # Делаем свой экземпляр и ставим курсор
            # КУРСОР нужен для перехода функционального языка формул на процедурный или для вставки процедурных кусков в функциональный скрипт.
            #
            # Способы реализации курсоров:
            #  - SQL, Transact-SQL,
            #  - серверные API-курсоры (OLE DB, ADO, ODBC),
            #  - клиентские API-курсоры (выборка кэшируется на клиенте)
            #
            # API-курсоры ODBC по SQLSetStmtAttr:
            #  - тип SQL_ATTR_CURSOR_TYPE:
            #    - однопроходный (последовательный доступ),
            #    - статический (копия в tempdb),
            #    - управляемый набор ключей,
            #    - динамический,
            #    - смешанный
            #  - режим работы в стиле ISO:
            #    - прокручиваемый SQL_ATTR_CURSOR_SCROLLABLE,
            #    - обновляемый (чувствительный) SQL_ATTR_CURSOR_SENSITIVITY

            # Клиентский однопроходной, статический API-курсор ODBC.
            # Добавляем атрибут seek...
            self.seek = self.cnxn.cursor()
            self.Result = True
        except Exception:
            self.Result = False
        return self.Result

    def disconnect(self):
        try:
            # Снимаем курсор
            self.seek.close()
            # Отключаемся от базы данных
            self.cnxn.close()
            print(" -- БД отключена")
        except Exception:
            print(" -- БД уже отключена")

    def getSQLDrivers(self):
        SQLDrivers = pyodbc.drivers()
        return SQLDrivers

    def getDataSources(self):
        DataSources = pyodbc.dataSources()
        return DataSources

    def getSQLData_odbc(self):
        SQLData = (self.cnxn.getinfo(pyodbc.SQL_SERVER_NAME),
                   self.cnxn.getinfo(pyodbc.SQL_DRIVER_NAME),
                   self.cnxn.getinfo(pyodbc.SQL_ODBC_VER),
                   self.cnxn.getinfo(pyodbc.SQL_DATA_SOURCE_NAME),
                   self.cnxn.getinfo(pyodbc.SQL_USER_NAME))
        return SQLData

    def getSQLData_mssql(self):
        SQLData = (self.cnxn.getinfo(pymssql.STRING),
                   self.cnxn.getinfo(pymssql.paramstyle),
                   self.cnxn.getinfo(pymssql.VERSION),
                   self.cnxn.getinfo(pymssql.get_dbversion()),
                   self.cnxn.getinfo(pymssql.apilevel))
        return SQLData
